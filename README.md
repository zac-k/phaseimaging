# phaseimaging

## Introduction
This library provides a variety of functions related to phase imaging. Some of the included functions can be used to process experimental images, but I have also included functions to simulate these images. For experimental data, pre-processing will be required for meaningful results. In the future, I will add image registration and other preprocessing functions to enable perfoming all steps after image acquisition using only this library.

Note that although I have coded most of the functions to allow for rectangular images and specimen arrays, most of my testing has used square and cubic arrays, so there is a potential for bugs if you are using rectangular arrays. Please let me know if you experience any issues with any of the functions.

## Functions
### import_specimen
Generates a 3D numpy array from a specimen file. Input format is a text file (sans the file extension) with each block of rows/columns representing a 2D slice of the binary specimen mask. Each block is separated by an empty line. Specimen files can be generated using my [random-specimen-generator](https://github.com/zac-k/random-specimen-generator) repository. One specimen file is included in the present repository as an example.

    import_specimen(specimen_file)

|  |  |  |
|---|---|---|
| Parameters: | **specimen_file**:*string* |  |
|  |  | Path of specimen file |
| Returns: | **specimen**:*ndarray* |  |
|  |  | Three-dimensional binary specimen mask. A value of `1` indicates a voxel where the specimen exists, and a value of `0` indicates a voxel where it does not. |
|  |  |  |

Note: Does not yet support rectangular (non-cubic) arrays.
### project_electrostatic_phase

Generates a phase map by projecting the electrostatic potential of the specimen in the z-direction.

    project_electrostatic_phase(specimen, accel_volt, mean_inner_potential, image_width)

|  |  |  |
|---|---|---|
| Parameters: | **specimen** : *array_like* |  |
|  |  | Three-dimensional binary specimen mask. |
|  | **accel_volt** : *float* |  |
|  |  | Electron accelerating voltage in volts. |
|  | **mean_inner_potential** : *complex float* |  |
|  |  | Constant mean inner electrostatic potential of the specimen. An imaginary component can be added for simulation of absorption. |
|  | **image_width** : *tuple*, *list* |  |
|  |  | Three element tuple or list containing the width of the specimen array in metres, in the x-, y-, and z-direction, respectively. |
| Returns: | **phase** : *ndarray* |  |
|  |  | Real, two-dimensional numpy array. The computed phase map. |

### project_magnetic_phase

Generate a phase map by projecting the magnetic vector potential of the specimen in the z-direction.

    project_magnetic_phase(specimen, mhat, magnetisation, image_width, k_kernel=None, inverse_k_squared_kernel=None)

|  |  |  |
|---|---|---|
| Parameters: | **specimen** : *array_like* |  |
|  |  | Three-dimensional binary specimen mask. |
|  | **mhat** : *tuple*, *list* |  |
|  |  | Magnetisation direction. A vector pointing in the direction of uniform magnetisation of the specimen. The length of this vector has no effect. It is advisable to use a unit vector for clarity. |
|  | **magnetisation** : *float* |  |
|  |  | Magnitude of the uniform magnetisation in A/m. |
|  | **image_width** : *tuple*, *list* |  |
|  |  | Three element tuple or list containing the width of the specimen array in metres, in the x-, y-, and z-direction, respectively. |
|  | **k_kernel** : *ndarray*, *optional* |  |
|  |  | Kernel of k-space vectors at z = 0. This can be saved from previous calculations provided that the size and resolution are the same. If this parameter is omitted, it will be generated by this function. |
|  | **inverse_k_squared_kernel** : *ndarray*, *optional* |  |
|  |  | Regularised inverse k^2 array. This can be saved from previous calculations provided that the size and resolution are the same. If this parameter is omitted, it will be generated by this function using the default regularisation parameter. |
| Returns: | **phase** : *ndarray* |  |
|  |  | Real, two-dimensional numpy array. The computed phase map. |

### transfer_image

Generate in- or out-of-focus intensity or wavefield from exit phase.

    transfer_image(defocus, wavelength, image_width, phase, is_image=True)

|  |  |  |
|---|---|---|
| Parameters: | **defocus** : *float* |   |
|  |  | Microscope defocus in metres. Positive for over-focus, negative for under-focus, and zero for in-focus. |
|  | **wavelength** : *float* |  |
|  |  | Wavelength of incident beam in metres |
|  | **image_width** : *tuple*, *list* |  |
|  |  | Three element tuple or list containing the width of the specimen array in metres, in the x-, y-, and z-direction, respectively. |
|  | **phase** : *ndarray* |  |
|  |  | Exit phase of the wavefield |
|  | **is_image** : *bool*, *optional* |  |
|  |  | If true, return will be the intensity at the in- or out-of-focus plane. If false, return will be the complex wavefield at the in- or out-of-focus plane. Default is `True`. |
| Returns: | **image** : *ndarray* |  |
|  |  | Computed image. The intensity or wavefield depending on the value of `is_image`. Default is intensity. |

### retrieve_phase_tie

Retrieves the exit phase from two or three out-of-focus images using the transport-of-intensity equation (TIE).

    retrieve_phase_tie(defocus, wavelength, image_width, image_under, image_over, image_in=None, image_intensity=1, k_kernel=None, inverse_k_squared_kernel=None, reg_param=0.1, reg_param_tie=None)
                       
                       
|  |  |  |
|---|---|---|
| Parameters: | **defocus** : *float* |   |
|  |  | Microscope defocus in metres. This should be positive; this function assumes that the under-focus image is at negative defocus, and the in-focus defocus is zero.  |
|  | **wavelength** : *float* |  |
|  |  | Wavelength of incident beam in metres. |
|  | **image_width** : *tuple*, *list* |  |
|  |  | Three element tuple or list containing the width of the specimen array in metres, in the x-, y-, and z-direction, respectively. |
|  | **image_under** : *ndarray* |  |
|  |  | Under-focus image. |
|  | **image_over** : *ndarray* |  |
|  |  | Over-focus image. |
|  | **image_in** : *ndarray*, *optional* |  |
|  |  | In-focus image. If not included, the function will compute the phase from the two out-of-focus images. This requires that `image_intensity` be set to the appropriate value if it is not `1`|
|  | **image_intensity** : *float* |  |
|  |  | The incident intensity; that is, the uniform intensity of the image in the absence of a specimen. Default is unity. Has no effect if an in-focus image is included. |
|  | **k_kernel**:*ndarray*, *optional* |  |
|  |  | Kernel of k-space vectors at z = 0. This can be saved from previous calculations provided that the size and resolution are the same. If this parameter is omitted, it will be generated by this function. |
|  | **inverse_k_squared_kernel**:*ndarray*, *optional* |  |
|  |  | Regularised inverse k^2 array. This can be saved from previous calculations provided that the size and resolution are the same. If this parameter is omitted, it will be generated by this function using the default regularisation parameter. |
|  | **reg_param** : *float*, *optional* |  |
|  |  | Regularisation parameter for the division by the in-focus intensity. Default is `0.1`. Has no effect if only two images are used. |
|  | **reg_param_tie** : *float*, *optional* |  |
|  |  | Regularisation parameter for the division by k^2. Uses the default if not included. Has no effect if `inverse_k_squared_kernel` is provided. |
| Returns: | **phase** : *ndarray* |  |
|  |  | Computed phase. |

### plot_image

Plots a numpy array as an image, for visualising phase, intensity, etc.

    plot_image(image, limits=None)

|  |  |  |
|---|---|---|
| Parameters: | **image** : *ndarray* |   |
|  |  | The array to be displayed as an image. For complex arrays, only the real part will be displayed, with a warning displayed on the command line.  |
|  | **limits** : *tuple*, *list*, *optional* |  |
|  |  | Two element tuple or list containing the minimum and maximum values to be displayed. Intensities outside these limits will be clipped. If omitted, grayscale will be scaled according to the maximum and minimum values of the image array.

### save_image

Similar to `plot_image`, but saves the visualisation in an image format rather than plotting it on-screen.

    save_image(image, output_path, limits=None)

|  |  |  |
|---|---|---|
| Parameters: | **image** : *ndarray* |   |
|  |  | The array to be saved as an image. For complex arrays, only the real part will be kept, with a warning displayed on the command line.  |
|   | **output_path** : *string* |   |
|  |  | The output path of the file to be saved. The extension will determine the format (e.g., 'png', 'eps', etc.).  |
|  | **limits** : *tuple*, *list*, *optional* |  |
|  |  | Two element tuple or list containing the minimum and maximum values to be displayed. Intensities outside these limits will be clipped. If omitted, grayscale will be scaled according to the maximum and minimum values of the image array.